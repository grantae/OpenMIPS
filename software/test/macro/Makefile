###############################################################################
#                                                                             #
#                     Simulation Harness for MIPS32r1                         #
#          Copyright (C) 2015 Grant Ayers <ayers@cs.stanford.edu>             #
#                                                                             #
# This Makefile implements the macro testing infrastructure for the MIPS32r1  #
# processor design. It allows simulating real assembly and C programs through #
# the full hardware pipeline. It builds one hardware simulation executable    #
# and runs it with different input memories for each test program. Each test  #
# is compiled with the GCC MIPS cross-compiler as a separate dependent step.  #
# These test programs are automatically discovered and built.                 #
#                                                                             #
# Typical Usage:                                                              #
#   make              : Compile all test programs and run all tests.          #
#   make test         : Same as 'make'.                                       #
#   make test_<foo>   : Compile and test only <foo>.                          #
#   make wave_<foo>   : View the waveform for test <foo>.                     #
#   make itrace_<foo> : Create an instruction trace for test <foo>.           #
#   make clean_all    : Delete all files generated by this Makefile           #
#   make clean        : Delete files which were generated by this Makefile    #
#                       except Xilinx cores.                                  #
#   make clean_test   : Clean test files only                                 #
#   make clean_sim    : Clean simulation executable files only                #
#                                                                             #
# Advanced Usage (command-line options):                                      #
#   - Define WAVE or ITRACE to enable those features, e.g.,                   #
#     'make test_xor ITRACE=1 WAVE=1'                                         #
#   - Define VERBOSE to see compilation output                                #
#   - Define BIG_ENDIAN=yes or BIG_ENDIAN=no to change the compilation mode   #
#   - Define DEBUG=yes to compile with debug info (shows up in objdump)       #
#                                                                             #
# Requirements:                                                               #
#   - Xilinx tools (ISE 14.7)                                                 #
#   - GNU make, bash, python, standard utils (sed, grep, awk, etc.)           #
#                                                                             #
###############################################################################

#---------- Device Settings ----------#
DEVICE            := xc6slx45t
SPEED             := 3
PACKAGE           := fgg484

#---------- Basic settings ----------#
BUILD_DIR         := build
HDL_DIR           := ../../../hardware/src
TST_ROOT          := tests
VERBOSE           ?= no
TST_TOOLCHAIN     := ../../gcc-mips/mips_tc
TST_UTIL          := ../../util
TST_MAKEFILE      := harness/Makefile_MIPS
TST_REPORTER      := harness/results.py
TST_CYCCHECK      := harness/cycle_check.sh
TST_WAVECFG       := harness/wave.wcfg
TST_SUMMARY_FILE  := $(BUILD_DIR)/latest_test_results
TST_RESULT_FILE   := test.result
TST_CYCLES_FILE   := test.cycles
TST_SCRATCH_FILE  := test.scratch
TST_ITRACE_FILE   := test.itrace
TST_RTRACE_FILE   := test.rtrace
TST_STDOUT_FILE   := test.stdout
TST_CONFIG_SIM    := test.conf
TST_CONFIG_CYC    := cycles.conf
TST_SRC_DIR       := src
TST_BUILD_DIR     := build
TST_RAM_IMAGE_KHI := khi.hex
TST_RAM_IMAGE_KLO := klo.hex
TST_RAM_IMAGE_APP := app.hex
TST_DUMPDB        := dump.wdb
export DEBUG      := no
export BIG_ENDIAN := no

#---------- Source file names/types  ----------#
VLOG_EXT          := .v
VHDL_EXT          := .vhdl
CORE_CFG_EXT      := .xcp
CORE_PRJ_EXT      := .cgp
CORE_OUT_EXT      := .xco
CORE_SRC_OUT_LST  := src_out.lst
TESTBENCH         := harness/mips_test.v
HDL_SRC_LST       := harness/$(DEVICE)-$(SPEED)-$(PACKAGE)/sources.lst
XIL_GLBL_V        := $(XILINX)/verilog/src/glbl.v

#---------- No need to modify below ----------#

#### Helper functions ####

# Given a test result file name, return the name of the test cycles reference file if it exists
test_cycles_ref = $(wildcard $(dir $(1))$(TST_CONFIG_CYC))

# Given a test result file name, return the name of the test cycles generated file
test_cycles_gen = $(dir $(1))$(TST_CYCLES_FILE)

# Given a test result file name, return the name of the test scratch register file
test_scratch_gen = $(dir $(1))$(TST_SCRATCH_FILE)

# Given a test result file name, return the name of the instruction trace file
test_itrace_gen = $(dir $(1))$(TST_ITRACE_FILE)

# Given a test result file name, return the name of the register file trace file
test_rtrace_gen = $(dir $(1))$(TST_RTRACE_FILE)

# Given a test result file name, return the name of the stdout log file
test_stdout_gen = $(dir $(1))$(TST_STDOUT_FILE)

# Given a file name, replace that name with the test result file name
test_result_gen = $(dir $(1))$(TST_RESULT_FILE)

# Given a test result file name, return the test's compilation outputs (RAM hex files)
test_imgs = $(foreach IMG,$(TST_RAM_IMAGES),$(dir $(1))$(TST_BUILD_DIR)/$(IMG))

# Given a test result file name (1), return the test's compilation output of type (2)
test_img  = $(dir $(1))$(TST_BUILD_DIR)/$(2)

# Given a test name, return the test result file name
test_result = $(filter $(TST_ROOT)/$(1)/$(TST_RESULT_FILE),$(TST_RESULTS))

# Given a test name, return the wave dump database name
test_wavedb = $(filter $(TST_ROOT)/$(1),$(TST_DIRS))/$(TST_DUMPDB)

# Given a test name, return the instruction trace name
test_itrace = $(filter $(TST_ROOT)/$(1),$(TST_DIRS))/$(TST_ITRACE_FILE)

# Given a test name, return the register file trace name
test_rtrace = $(filter $(TST_ROOT)/$(1),$(TST_DIRS))/$(TST_RTRACE_FILE)

# Given a filename containing a list of sources (1), return only the specified type (2)
# Also change the wildcard *FILL* to (3)
src_reader = $(shell grep -v -e '^\ *\#' -e '^$$' < $(1) | grep '$(2)$$' | sed 's|\*FILL\*|$(3)|')

# Given a pathname of a core project (.xco) file(s), return a list of its generated source files
core_gen_srcs = $(foreach FILE,$(1),$(shell sed -e 's|^|$(dir $(FILE))|' < $(dir $(FILE))$(CORE_SRC_OUT_LST)))

# Search for the first instance of a program in PATH
pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,$(PATH)))))

#### Precomputed variables ####

SHELL             := $(call pathsearch,bash)
PART              := $(DEVICE)-$(SPEED)-$(PACKAGE)
BLD_DIR_PART      := $(BUILD_DIR)/$(PART)
SIM_BLD_DIR       := $(BLD_DIR_PART)/$(basename $(notdir $(TESTBENCH)))
SIM_EXE_FILE      := $(SIM_BLD_DIR)/$(basename $(notdir $(TESTBENCH)))
SIM_PRJ_FILE      := $(addsuffix .prj,$(SIM_BLD_DIR)/$(basename $(notdir $(TESTBENCH))))
SIM_HDL_VLOG_SRCS := $(call src_reader,$(HDL_SRC_LST),$(VLOG_EXT),$(HDL_DIR))
SIM_HDL_VHDL_SRCS := $(call src_reader,$(HDL_SRC_LST),$(VHDL_EXT),$(HDL_DIR))
SIM_HDL_CORE_SRCS := $(addprefix $(BLD_DIR_PART)/,$(call src_reader,$(HDL_SRC_LST),$(CORE_OUT_EXT),$(notdir $(HDL_DIR))))
SIM_HDL_SRCS      := $(SIM_HDL_VLOG_SRCS) $(SIM_HDL_VHDL_SRCS) $(SIM_HDL_CORE_SRCS)
TST_DIRS          := $(shell find $(TST_ROOT) -mindepth 1 -maxdepth 1 -type d -print)
TST_NAMES         := $(addprefix test_,$(notdir $(TST_DIRS)))
TST_RESULTS       := $(addsuffix /$(TST_RESULT_FILE),$(TST_DIRS))
TST_RAM_IMAGES    := $(TST_RAM_IMAGE_KHI) $(TST_RAM_IMAGE_KLO) $(TST_RAM_IMAGE_APP)
TST_IMGS          := $(foreach IMG,$(TST_RAM_IMAGES),$(addsuffix /$(TST_BUILD_DIR)/$(IMG),$(TST_DIRS)))
WAV_NAMES         := $(addprefix wave_,$(notdir $(TST_DIRS)))
WAV_DUMPS         := $(addsuffix /$(TST_DUMPDB),$(TST_DIRS))
ITRACE_NAMES      := $(addprefix itrace_,$(notdir $(TST_DIRS)))
ITRACE_FILES      := $(addsuffix /$(TST_ITRACE_FILE),$(TST_DIRS))
RTRACE_NAMES      := $(addprefix rtrace_,$(notdir $(TST_DIRS)))
RTRACE_FILES      := $(addsuffix /$(TST_RTRACE_FILE),$(TST_DIRS))
REPORTALL         := 0

TST_UPDATE_TGTS   := $(addsuffix _update,$(TST_DIRS))

# Set verbosity
ifeq ($(VERBOSE),no)
    REDIR   := > /dev/null 2>&1
else
    REDIR   :=
endif


.PHONY: all
all: test


#### Run one or all tests ####

.PHONY: test
test: REPORTALL=1
test: test_reset $(TST_NAMES)
	@$(TST_REPORTER) -r $(TST_SUMMARY_FILE)

.PHONY: test_reset
test_reset:
	@rm -f $(TST_SUMMARY_FILE)

.SECONDEXPANSION:
.PHONY: $(TST_NAMES)
$(TST_NAMES): test_%: $$(call test_result,$$*)
	@if [ '$(REPORTALL)' -eq '0' ]; then rm -f $(TST_SUMMARY_FILE); fi
	@printf '$* %s\n' $$(cat $(call test_result,$*)) >> $(TST_SUMMARY_FILE)
	@if [ '$(REPORTALL)' -eq '0' ]; then $(TST_REPORTER) -r $(TST_SUMMARY_FILE); fi


# Build the simulation command for each test. This command is conditional on several options,
# including whether or not to create an instruction trace or the waveform database.
CMD_BASE = cd $(dir $(SIM_EXE_FILE)) && ./$(notdir $(SIM_EXE_FILE)) $(shell cat $(dir $@)$(TST_CONFIG_SIM)) \
           -testplusarg khigh_mem=$(abspath $(call test_img,$@,$(TST_RAM_IMAGE_KHI))) \
           -testplusarg klow_mem=$(abspath $(call test_img,$@,$(TST_RAM_IMAGE_KLO))) \
           -testplusarg vm_mem=$(abspath $(call test_img,$@,$(TST_RAM_IMAGE_APP))) \
           -testplusarg test_result=$(abspath $(call test_result_gen,$@)) \
           -testplusarg test_cycles=$(abspath $(call test_cycles_gen,$@)) \
           -testplusarg scratch_result=$(abspath $(call test_scratch_gen,$@)) \
           -testplusarg stdout=$(abspath $(call test_stdout_gen,$@))
CMD_ITRACE = -testplusarg itrace=$(abspath $(call test_itrace_gen,$@))
CMD_RTRACE = -testplusarg regtrace=$(abspath $(call test_rtrace_gen,$@))
CMD_NOWAVE = <<< "run all" > $(abspath $(dir $@)sim.log) 2>&1
CMD_WAVE   = -wdb $(abspath $(dir $@)$(TST_DUMPDB)) \
             <<< "wave log -r /; run all" > $(abspath $(dir $@)sim.log) 2>&1

# Final function to use for the test simulation command
gen_command = $(CMD_BASE) $(if $(ITRACE),$(CMD_ITRACE)) $(if $(RTRACE),$(CMD_RTRACE)) $(if $(WAVE),$(CMD_WAVE),$(CMD_NOWAVE))

$(TST_RESULTS): $(SIM_EXE_FILE) $$(dir $$@)$(TST_CONFIG_SIM) $$(call test_imgs,$$@) $$(call test_cycles_ref,$$@) | check-env
	@echo '[Test]        $@'
	@$(call gen_command)
	@$(if $(call test_cycles_ref,$@),$(TST_CYCCHECK) $(call test_cycles_ref,$@) $(call test_cycles_gen,$@) $@)


#### View the waveform for a test ####

.PHONY: $(WAV_NAMES)
$(WAV_NAMES): wave_%: $$(call test_wavedb,$$*) | check-env
	@echo '[Wave]        $<'
	@cd $(dir $(call test_wavedb,$*)) && isimgui -view $(abspath $(TST_WAVECFG))

$(WAV_DUMPS): WAVE=1
$(WAV_DUMPS): %/$(TST_DUMPDB): $(SIM_EXE_FILE) $$(dir $$@)$(TST_CONFIG_SIM) $$(call test_imgs,$$@) $$(call test_cycles_ref,$$@) | check-env
	@$(call gen_command)


#### Create an instruction trace for a test ####

.PHONY: $(ITRACE_NAMES)
$(ITRACE_NAMES): itrace_%: $$(call test_itrace,$$*) | check-env
	@echo '[i-trace]     $<'

$(ITRACE_FILES): ITRACE=1
$(ITRACE_FILES): %/$(TST_ITRACE_FILE): $(SIM_EXE_FILE) $$(dir $$@)$(TST_CONFIG_SIM) $$(call test_imgs,$$@) $$(call test_cycles_ref,$$@) | check-env
	@$(call gen_command)


#### Create a register file trace for a test ####

.PHONY: $(RTRACE_NAMES)
$(RTRACE_NAMES): rtrace_%: $$(call test_rtrace,$$*) | check-env
	@echo '[r-trace]     $<'

$(RTRACE_FILES): RTRACE=1
$(RTRACE_FILES): %/$(TST_RTRACE_FILE): $(SIM_EXE_FILE) $$(dir $$@)$(TST_CONFIG_SIM) $$(call test_imgs,$$@) $$(call test_cycles_ref,$$@) | check-env
	@$(call gen_command)


#### Compile the tests ####

build_tests: $(TST_IMGS)

%/$(TST_BUILD_DIR)/$(TST_RAM_IMAGE_KHI) %/$(TST_BUILD_DIR)/$(TST_RAM_IMAGE_KLO) %/$(TST_BUILD_DIR)/$(TST_RAM_IMAGE_APP): %_update ;

.PHONY: $(TST_UPDATE_TGTS)
$(TST_UPDATE_TGTS): %_update:
	@$(MAKE) -s -f $(abspath $(TST_MAKEFILE)) -C $*/ MIPS_BASE=$(abspath $(TST_TOOLCHAIN)) UTIL_BASE=$(abspath $(TST_UTIL)) \
     SOURCE_BASE=$(TST_SRC_DIR) BUILD_BASE=$(TST_BUILD_DIR) QUIET=1 TEST_NAME=$*


#### Create a simulation executable from the HDL source files ####

.PHONY: sim
sim: $(SIM_EXE_FILE)

$(SIM_EXE_FILE): $(SIM_PRJ_FILE) | check-env
	@echo '[Sim Exe]     $@'
	@rm -f $@
	@cd $(dir $@) && vlogcomp -intstyle silent -prj $(notdir $(SIM_PRJ_FILE))
	@cd $(dir $@) && vhpcomp  -intstyle silent -prj $(notdir $(SIM_PRJ_FILE))
	@cd $(dir $@) && fuse -incremental -lib unisims_ver -lib unimacro_ver -lib xilinxcorelib_ver \
     -lib secureip -o $(notdir $@) -prj $(notdir $(SIM_PRJ_FILE)) work.$(basename $(notdir $(TESTBENCH))) work.glbl $(REDIR)


#### Create a project file for the test executable ####

.PHONY: prj
prj: $(SIM_PRJ_FILE)

$(SIM_PRJ_FILE): $(HDL_SRC_LST) $(SIM_HDL_SRCS)
	@echo '[Sim Prj]     $@'
	@rm -f $@
	@mkdir -p $(dir $@)
	@echo $(abspath $(SIM_HDL_VLOG_SRCS)) | tr ' ' '\n' | grep '.$(VLOG_EXT)$$' | awk 'NF {print "verilog work \"" $$0 "\""}' > $@
	@echo $(abspath $(SIM_HDL_VHDL_SRCS)) | tr ' ' '\n' | grep '.$(VHDL_EXT)$$' | awk 'NF {print "vhdl work \"" $$0 "\""}' >> $@
	@echo $(abspath $(call core_gen_srcs,$(SIM_HDL_CORE_SRCS))) | tr ' ' '\n' | grep '.$(VLOG_EXT)$$' | awk 'NF {print "verilog work \"" $$0 "\""}' >> $@
	@echo $(abspath $(call core_gen_srcs,$(SIM_HDL_CORE_SRCS))) | tr ' ' '\n' | grep '.$(VHDL_EXT)$$' | awk 'NF {print "vhdl work \"" $$0 "\""}' >> $@
	@echo 'verilog work "$(XIL_GLBL_V)"' >> $@


#### Build Xilinx cores using coregen ####

.PHONY: cores
cores: $(SIM_HDL_CORE_SRCS)

$(SIM_HDL_CORE_SRCS): $(BLD_DIR_PART)/%$(CORE_OUT_EXT): | check-env
	@echo '[Coregen]     $@'
	@rm -rf '$(dir $@)*'
	@mkdir -p '$(dir $@)'
	@cp -r $(dir $(HDL_DIR))$(dir $*)* $(dir $@)
	@cd $(dir $@) && coregen -intstyle silent -b $(notdir $*)$(CORE_CFG_EXT) -p $(notdir $*)$(CORE_PRJ_EXT) $(REDIR)


#### Check that Xilinx tools are available ####

.PHONY: check-env
check-env:
ifndef XILINX
	$(error The XILINX environment variable is undefined)
endif
ifndef SHELL
	$(error Bash not found)
endif


#### Clean up ####

.PHONY: clean_all
clean_all: clean_test clean_cores_sim

.PHONY: clean
clean: clean_test clean_sim

.PHONY: clean_test
clean_test:
	@for d in $(TST_DIRS); do (cd $$d && $(MAKE) -s -f $(abspath $(TST_MAKEFILE)) clean; \
     rm -f $(TST_RESULT_FILE) $(TST_CYCLES_FILE) $(TST_SCRATCH_FILE) $(TST_ITRACE_FILE) $(TST_RTRACE_FILE) $(TST_STDOUT_FILE) sim.log; \
     rm -f $(basename $(TST_DUMPDB))*$(suffix $(TST_DUMPDB)) ); done

.PHONY: clean_sim
clean_sim:
	@rm -rf $(SIM_BLD_DIR)
	@rm -f $(TST_SUMMARY_FILE)
	@if [ -d $(BUILD_DIR) ] ; then find $(BUILD_DIR) -empty -type d -delete ; fi

.PHONY: clean_cores_sim
clean_cores_sim:
	@rm -rf $(BUILD_DIR)/$(PART)
	@rm -f $(TST_SUMMARY_FILE)
	@if [ -d $(BUILD_DIR) ] ; then find $(BUILD_DIR) -empty -type d -delete ; fi
